/******************************************************
 * Filename: ReadMe
 *
 * Description: documentation for project4
 *
 * Group: SegFault
 * Authors: Lucas Stuyvesant, Garrett Ransom,
 *     Jonathan Brandt, Travis Nordquist
 * Class: CSE 325
 * Instructor: Zheng
 * Assignment: Lab Project #4
 * Assigned: March 4,2016
 * Due: March 25, 2016
******************************************************/

Description/Goals: The fourth project has the primary goal of simulating the process scheduling of an OS.  It allows for the choice of three different scheduling algorithms: first-come first-served, Shortest remaining Job first, and round robin.  The user provides a file of input containing the list of processes with their burst times and arrive times. The user chooses the desired scheduling algorithm and a time-quantum when needed.  The program then simulates each of the processes arriving, running, and waiting for new arrivals, ending with a quick printed analysis of average waiting time, average response time, average turnaround time, and the CPU utilization.


Implementation:  The implementation of this program involves many aspects of the second project.  The queues used in project two have been modified to fit the data bits from the input file.  the Process sets have also been modified to hold PID, arrival time, burst time and a flag for internal use of response.  We used a couple of different queues to store the list of processes to be fed to the Ready-queue once the arrival time has come.  The two queues (toArrive and Ready) work in conjunction for the processes which still need to complete their cycles. The program then cycles one time unit at a time, designating and handling new processes, currently running processes, and processes waiting, all based upon the scheduling algorithm designated by the user.     
 


Testing Results: Testing involved testing sets of many varying sizes, starting with small, quick and in order lists of processes, working up to larger, out of order lists to ensure quick testing.  Once the program compiled and ran without segfaults or errors, we began checking accuracy of the algorithms.  We started with first-come first-served since it was easiest to determine if execution order was correct and thus the simulated CPU usage was accurate.  Once the few kinks were sorted, we moved to SJF, then round robin.  To test the scheduling of these, we had a by hand copy of the order in which the processes should arrive, begin executing, and finish execution.  We compared these hand copies to the output of the program and worked the small ordering issues as they were found.  Once we determined order and timing was correct for all three algorithms, we tested that the statistics were calculated correctly by the program.  The only issue we found with these stats were in CPU usage, which we easily corrected upon realizing our calculation formula was wrong.  With varying size and ordering of the input files, we found no issues with our program. 

Bugs:

No known bugs to report

Additional Notes:

